import {writeFileSync} from 'fs';
import {inspect} from 'util';
import * as types from 'babel-types';

function isKeyword(n) {
  return n === 'extends' || n === 'arguments' || n === 'static';
}
function getTypeFromValidator(validator) {
  if (validator.type) {
    return validator.type;
  } else if (validator.oneOfNodeTypes) {
    return validator.oneOfNodeTypes.join(' | ');
  } else if (validator.oneOfNodeOrValueTypes) {
    return validator.oneOfNodeOrValueTypes.join(' | ');
  } else if (validator.oneOf) {
    return validator.oneOf.map(val => inspect(val)).join(' | ');
  } else if (validator.chainOf) {
    if (
      validator.chainOf.length === 2 &&
      validator.chainOf[0].type === 'array' &&
      validator.chainOf[1].each
    ) {
      return (
        '$ReadOnlyArray<' +
        getTypeFromValidator(validator.chainOf[1].each) +
        '>'
      );
    }
    if (
      validator.chainOf.length === 2 &&
      validator.chainOf[0].type === 'string' &&
      validator.chainOf[1].oneOf
    ) {
      return validator.chainOf[1].oneOf
        .map(function(val) {
          return JSON.stringify(val);
        })
        .join(' | ');
    }
  }
  const err = new Error('Unrecognised validator type');
  err.code = 'UNEXPECTED_VALIDATOR_TYPE';
  err.validator = validator;
  throw err;
}

const customTypes = {
  ClassMethod: {
    key: `Expression`,
  },
  Identifier: {
    name: `string`,
  },
  MemberExpression: {
    property: `Expression`,
  },
  ObjectMethod: {
    key: `Expression`,
  },
  ObjectProperty: {
    key: `Expression`,
  },
};

function getType(key, field) {
  const validator = types.NODE_FIELDS[key][field].validate;
  if (customTypes[key] && customTypes[key][field]) {
    return customTypes[key][field];
  } else if (validator) {
    try {
      return getTypeFromValidator(types.NODE_FIELDS[key][field].validate);
    } catch (ex) {
      if (ex.code === 'UNEXPECTED_VALIDATOR_TYPE') {
        console.log('Unrecognised validator type for ' + key + '.' + field);
        console.dir(ex.validator, {depth: 10, colors: true});
      } else {
        throw ex;
      }
      return 'mixed';
    }
  } else {
    return 'mixed';
  }
}

const aliases = {};
const output = [`// generated by scripts/generate-babel-types.js`, ``];
output.push(
  `type Location = {start: {line: number, column: number}, end: {line: number, column: number}};`,
);
output.push(``);
Object.keys(types.BUILDER_KEYS)
  .sort()
  .forEach(key => {
    output.push(`declare class ${key} {`);
    output.push(`  type: '${key}';`);
    output.push(`  loc: ?Location;`);
    Object.keys(types.NODE_FIELDS[key])
      .sort(function(fieldA, fieldB) {
        const indexA = types.BUILDER_KEYS[key].indexOf(fieldA);
        const indexB = types.BUILDER_KEYS[key].indexOf(fieldB);
        if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
        if (indexA === -1) return 1;
        if (indexB === -1) return -1;
        return indexA - indexB;
      })
      .forEach(function(field) {
        const t = getType(key, field);
        const optional = types.NODE_FIELDS[key][field].optional ? '?' : '';
        if (field === 'static') {
          return;
        }
        output.push(`  ${field}: ${optional}${t};`);
      });
    output.push(``);

    (types.ALIAS_KEYS[key] || []).concat(['BabelNode']).forEach(k => {
      output.push(`  // alias: ${k}`);
      if (!aliases[k]) aliases[k] = [];
      aliases[k].push(key);
    });

    output.push(`}`);
    output.push(``);
  });

Object.keys(aliases).forEach(key => {
  output.push(`type ${key} = (`);
  aliases[key].sort().forEach(k => {
    output.push(`  | ${k}`);
  });
  output.push(`);`);
  output.push(``);
});

output.push(
  `type JSXValue = JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement;`,
);

writeFileSync(__dirname + '/babel-nodes.js', output.join('\n'));

const bt = [`// @flow`, `// generated by scripts/generate-babel-types.js`, ``];
bt.push(``);
bt.push(`let t: any = null;`);
bt.push(`let currentLocation: any = null;`);
bt.push(
  `export function getCurrentLocation(): Location { return currentLocation; }`,
);
bt.push(
  `export function setCurrentLocation(loc: Location): Location { return currentLocation = loc; }`,
);
bt.push(
  `export function setBabelTypes(_t: Object): Location { return t = _t; }`,
);
bt.push(``);
bt.push(`const BabelTypes = {`);
Object.keys(types.BUILDER_KEYS)
  .sort()
  .forEach(key => {
    bt.push(
      `  ${key[0].toLowerCase() + key.substr(1)}(${types.BUILDER_KEYS[key]
        .map(field => {
          const t = getType(key, field);
          const isOptional = !!types.NODE_FIELDS[key][field].optional;
          const hasDefault = types.NODE_FIELDS[key][field].default !== null;
          const optional = isOptional || hasDefault ? '?' : '';
          return `${isKeyword(field) ? '_' + field : field}: ${optional}${t}`;
        })
        .join(', ')}): ${key} {`,
    );
    bt.push(`    const args = ([].slice: any).call(arguments);`);
    bt.push(`    let loc = args[args.length - 1];`);
    bt.push(
      `    const hasLoc = (loc && typeof loc === 'object' && typeof loc.start === 'object' && typeof loc.end === 'object');`,
    );
    bt.push(`    if (hasLoc) {`);
    bt.push(`      args.pop();`);
    bt.push(`    }`);
    bt.push(
      `    return {...t.${key}.apply(t, args), loc: hasLoc ? (loc: any) : getCurrentLocation()};`,
    );
    bt.push(`  },`);
  });
Object.keys(types.BUILDER_KEYS)
  .sort()
  .forEach(key => {
    bt.push(`  is${key}(value: any, opts?: Object): boolean {`);
    bt.push(`    return t.is${key}.apply(t, arguments);`);
    bt.push('  },');
  });
Object.keys(types.BUILDER_KEYS)
  .sort()
  .forEach(key => {
    bt.push(`  assert${key}(value: ${key}, opts?: Object): mixed {`);
    bt.push(`    return t.assert${key}.apply(t, arguments);`);
    bt.push('  },');
  });
Object.keys(types.BUILDER_KEYS)
  .sort()
  .forEach(key => {
    bt.push(`  as${key}(value: any, opts?: Object): ${key} | void {`);
    bt.push(
      `    return t.is${key}.apply(t, arguments) ? (value: any) : undefined;`,
    );
    bt.push('  },');
  });
bt.push(`}`);
bt.push(``);
bt.push(`export default BabelTypes;`);
bt.push(``);

writeFileSync(__dirname + '/../src/babel-types.js', bt.join('\n'));
